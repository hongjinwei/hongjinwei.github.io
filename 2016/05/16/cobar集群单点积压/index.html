<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="cobar,MySQL," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="Cobar集群积压问题一直困扰的集群单点积压之前我们的cobar集群一直出现单点故障，一直有一个结点的插入和update操作积压非常严重。在cobar的master结点上，用
1netstat -anop |awk &amp;apos;$5~/192.168/&amp;apos; |awk &amp;apos;&amp;#123;print $4&amp;quot;\t&amp;quot;$5;&amp;#125;&amp;apos;|grep &amp;quot;^">
<meta property="og:type" content="article">
<meta property="og:title" content="cobar集群单点积压">
<meta property="og:url" content="http://yoursite.com/2016/05/16/cobar集群单点积压/index.html">
<meta property="og:site_name" content="Home">
<meta property="og:description" content="Cobar集群积压问题一直困扰的集群单点积压之前我们的cobar集群一直出现单点故障，一直有一个结点的插入和update操作积压非常严重。在cobar的master结点上，用
1netstat -anop |awk &amp;apos;$5~/192.168/&amp;apos; |awk &amp;apos;&amp;#123;print $4&amp;quot;\t&amp;quot;$5;&amp;#125;&amp;apos;|grep &amp;quot;^">
<meta property="og:updated_time" content="2016-05-25T06:51:11.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="cobar集群单点积压">
<meta name="twitter:description" content="Cobar集群积压问题一直困扰的集群单点积压之前我们的cobar集群一直出现单点故障，一直有一个结点的插入和update操作积压非常严重。在cobar的master结点上，用
1netstat -anop |awk &amp;apos;$5~/192.168/&amp;apos; |awk &amp;apos;&amp;#123;print $4&amp;quot;\t&amp;quot;$5;&amp;#125;&amp;apos;|grep &amp;quot;^">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> cobar集群单点积压 | Home </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?75d688b5237e9e5c1aa369cdb7c337e1";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Home</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="#" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>


    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                cobar集群单点积压
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-16T22:29:44+08:00" content="2016-05-16">
              2016-05-16
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/16/cobar集群单点积压/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/16/cobar集群单点积压/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Cobar集群积压问题"><a href="#Cobar集群积压问题" class="headerlink" title="Cobar集群积压问题"></a>Cobar集群积压问题</h1><h2 id="一直困扰的集群单点积压"><a href="#一直困扰的集群单点积压" class="headerlink" title="一直困扰的集群单点积压"></a>一直困扰的集群单点积压</h2><p>之前我们的cobar集群一直出现单点故障，一直有一个结点的插入和update操作积压非常严重。在cobar的master结点上，用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -anop |awk &apos;$5~/192.168/&apos; |awk &apos;&#123;print $4&quot;\t&quot;$5;&#125;&apos;|grep &quot;^:&quot; |awk -F &apos;:&apos; &apos;&#123;print $8;&#125;&apos; |sort |uniq -c</span><br></pre></td></tr></table></figure>
<p>查看到每个结点的连接数目，可以看到有一个结点连接数目非常高，一般连接数目都是100左右，有一个达到了700-800之多，流量明显不正常。而且集群速度非常慢，内容由于处理慢，积压严重。</p>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>开启sql单点的慢查询日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//查看慢查询时间</span><br><span class="line">mysql&gt; show variables like &quot;long_query_time&quot;;默认10s</span><br><span class="line">//查看慢查询配置情况</span><br><span class="line">mysql&gt; show status like &quot;%slow_queries%&quot;;</span><br><span class="line">//查看慢查询日志路径</span><br><span class="line">mysql&gt; show variables like &quot;%slow%&quot;;</span><br><span class="line">//开启日志</span><br><span class="line">mysql&gt; set global slow_query_log=ON;</span><br><span class="line">//设置时间</span><br><span class="line">mysql&gt; set global slow_launch_time=5;</span><br></pre></td></tr></table></figure>
<p>  或者直接修改my.cnf</p>
<pre><code>slow_query_log_file=/mysql/log/nagiosdb-slow.log
slow_launch_time=5
</code></pre><p>  在慢查询日志中，可以看到一些比较慢的查询，发现一般insert的语句竟然达到了300s，匪夷所思。而一般的select语句一般时间都不长。</p>
<p>  一般来说，我们的cobar集群是用id来做路由， 而id是用MD5算法生成的，也就是说，路由一般都是比较均衡的，而且看流量每个结点的流量是差不多的。</p>
<h2 id="尝试解决"><a href="#尝试解决" class="headerlink" title="尝试解决"></a>尝试解决</h2><p>  由于非常稳定的只有那一个单点出现问题，因而尝试把那个结点下线，替换了一个全新的结点上去，在下线的主机测试了一下服务器磁盘的I/O，发现磁盘IO比较慢， 但是不至于那么慢。换上新结点之后，cobar集群正常。</p>
<h2 id="问题再现"><a href="#问题再现" class="headerlink" title="问题再现"></a>问题再现</h2><p>  正常了一段时间之后，紧挨着这个结点之后的下一个结点又出现了同样的问题！真是令人头疼。</p>
<h2 id="fix"><a href="#fix" class="headerlink" title="fix!"></a>fix!</h2><p>  进mysql结点查看了一下processlist</p>
<pre><code>mysql&gt;show processlist;
</code></pre><p>  发现大量的insert，update积压，这时候查看了一下mysql的配置，发现mysql几乎没有任何的优化配置，因而去搜了一下mysql的优化配置。发现了非常关键的一点：        </p>
<pre><code>innodb_buffer_pool_size
</code></pre><p> 我们的表用了大量索引，而这个配置是对索引的缓存，这就好解释为什么insert和update非常费时，因为新数据需要改动索引，而select则不需要。另外，我还增加了</p>
<pre><code>query_cache_size=40M
query_cache_type=1
</code></pre><p> 来配置ResultSet的缓存，以增加读库的缓存，提升读库速度。</p>
<p>附上MySQL的一些优化参数</p>
<h2 id="MySQL非缓存参数变量介绍及修改"><a href="#MySQL非缓存参数变量介绍及修改" class="headerlink" title="MySQL非缓存参数变量介绍及修改"></a>MySQL非缓存参数变量介绍及修改</h2><h3 id="back-log"><a href="#back-log" class="headerlink" title="back_log"></a>back_log</h3><h3 id="wait-timeout"><a href="#wait-timeout" class="headerlink" title="wait_timeout"></a>wait_timeout</h3><blockquote>
<p>修改wait_timeout参数值，由默认的8小时，修改为30分钟。(本次不用)<br>          wait_timeout=1800（单位为秒）</p>
   <p><br>        我对wait-timeout这个参数的理解：MySQL客户端的数据库连接闲置最大时间值。<br><br>        说得比较通俗一点，就是当你的MySQL连接闲置超过一定时间后将会被强行关闭。MySQL默认的wait-timeout  值为8个小时，可以通过命令show variables like ‘wait_timeout’查看结果值;。<br>        设置这个值是非常有意义的，比如你的网站有大量的MySQL链接请求（每个MySQL连接都是要内存资源开销的 ），由于你的程序的原因有大量的连接请求空闲啥事也不干，白白占用内存资源，或者导致MySQL超过最大连接数从来无法新建连接导致“Too many connections”的错误。在设置之前你可以查看一下你的MYSQL的状态（可用show processlist)，如果经常发现MYSQL中有大量的Sleep进程，则需要 修改wait-timeout值了。<br>        interactive_timeout：服务器关闭交互式连接前等待活动的秒数。交互式客户端定义为在mysql_real_connect()中使用CLIENT_INTERACTIVE选项的客户端。<br>        wait_timeout:服务器关闭非交互连接之前等待活动的秒数。在线程启动时，根据全局wait_timeout值或全局 interactive_timeout值初始化会话wait_timeout值，取决于客户端类型(由mysql_real_connect()的连接选项CLIENT_INTERACTIVE定义).<br>        这两个参数必须配合使用。否则单独设置wait_timeout无效<br>   </p>

</blockquote>
<h3 id="max-connections"><a href="#max-connections" class="headerlink" title="max_connections"></a>max_connections</h3><blockquote>
<p>修改max_connections参数值，由默认的151，修改为3000（750M）。</p>
   <p><br>       max_connections=3000<br>       max_connections是指MySql的最大连接数，如果服务器的并发连接请求量比较大，建议调高此值，以增加并行连接数量，当然这建立在机器能支撑的情况下，因为如果连接数越多，介于MySql会为每个连接提供连接缓冲区，就会开销越多的内存，所以要适当调整该值，不能盲目提高设值。可以过’conn%’通配符查看当前状态的连接数量，以定夺该值的大小。<br>        MySQL服务器允许的最大连接数16384；<br><br>        查看系统当前最大连接数：<br>        show variables like ‘max_connections’;<br>   </p>

</blockquote>
<h3 id="max-user-connections"><a href="#max-user-connections" class="headerlink" title="max_user_connections"></a>max_user_connections</h3><blockquote>
<p> 修改max_user_connections值，由默认的0，修改为800</p>
   <p><br>       max_user_connections=800<br>       max_user_connections是指每个数据库用户的最大连接<br>       针对某一个账号的所有客户端并行连接到MYSQL服务的最大并行连接数。简单说是指同一个账号能够同时连接到mysql服务的最大连接数。设置为0表示不限制。<br>        目前默认值为：0不受限制。<br>        这儿顺便介绍下Max_used_connections:它是指从这次mysql服务启动到现在，同一时刻并行连接数的最大值。它不是指当前的连接情况，而是一个比较值。如果在过去某一个时刻，MYSQL服务同时有1000个请求连接过来，而之后再也没有出现这么大的并发请求时，则Max_used_connections=1000.请注意与show variables 里的max_user_connections的区别。默认为0表示无限大。<br>        查看max_user_connections值<br>        show variables like ‘max_user_connections’;<br>   </p>


</blockquote>
<h3 id="thread-concurrency"><a href="#thread-concurrency" class="headerlink" title="thread_concurrency"></a>thread_concurrency</h3><blockquote>
<p>4.1.5修改thread_concurrency值，由目前默认的8，修改为64</p>
   <p><br>     thread_concurrency=64<br>        thread_concurrency的值的正确与否, 对mysql的性能影响很大, 在多个cpu(或多核)的情况下，错误设置了thread_concurrency的值, 会导致mysql不能充分利用多cpu(或多核), 出现同一时刻只能一个cpu(或核)在工作的情况。<br>        thread_concurrency应设为CPU核数的2倍. 比如有一个双核的CPU, 那thread_concurrency  的应该为4; 2个双核的cpu, thread_concurrency的值应为8.<br>        比如：根据上面介绍我们目前系统的配置，可知道为4个CPU,每个CPU为8核，按照上面的计算规则，这儿应为:4<em>8</em>2=64<br>        查看系统当前thread_concurrency默认配置命令：<br>       show variables like ‘thread_concurrency’;<br>   </p> 

</blockquote>
<h3 id="skip-name-resolve"><a href="#skip-name-resolve" class="headerlink" title="skip-name-resolve"></a>skip-name-resolve</h3><blockquote>
<p>4.1.6添加skip-name-resolve，默认被注释掉，没有该参数。</p>
   <p><br>        skip-name-resolve<br>        skip-name-resolve：禁止MySQL对外部连接进行DNS解析，使用这一选项可以消除MySQL进行DNS解析的时间。但需要注意，如果开启该选项，则所有远程主机连接授权都要使用IP地址方式，否则MySQL将无法正常处理连接请求！<br>   </p>

</blockquote>
<h3 id="skip-networking"><a href="#skip-networking" class="headerlink" title="skip-networking"></a>skip-networking</h3><blockquote>
<p>4.1.7 skip-networking，默认被注释掉。没有该参数。（本次无用）</p>
   <p><br>       skip-networking建议被注释掉，不要开启<br>       开启该选项可以彻底关闭MySQL的TCP/IP连接方式，如果WEB服务器是以远程连接的方式访问MySQL数据库服务器则不要开启该选项！否则将无法正常连接！<br>   </p>

</blockquote>
<h3 id="default-storage-engine"><a href="#default-storage-engine" class="headerlink" title="default-storage-engine"></a>default-storage-engine</h3><blockquote>
<p>4.1.8  default-storage-engine(设置MySQL的默认存储引擎)</p>
   <p><br>       default-storage-engine= InnoDB(设置InnoDB类型，另外还可以设置MyISAM类型)<br>       设置创建数据库及表默认存储类型<br>       show table status like ‘tablename’显示表的当前存储状态值<br>       查看MySQL有哪些存储状态及默认存储状态<br>        show engines;<br>        创建表并指定存储类型<br>        CREATE TABLE mytable (id int, title char(20)) ENGINE = INNODB;<br>        修改表存储类型：<br>        Alter table tableName engine =engineName<br><br>       备注：设置完后把以下几个开启：<br>       # Uncomment the following if you are using InnoDB tables<br>       innodb_data_home_dir = /var/lib/mysql<br><br>       #innodb_data_file_path = ibdata1:1024M;ibdata2:10M:autoextend（要注释掉，否则会创建一个新的把原来的替换的。）<br>       innodb_log_group_home_dir = /var/lib/mysql<br>       # You can set .._buffer_pool_size up to 50 - 80 %<br>       # of RAM but beware of setting memory usage too high<br>       innodb_buffer_pool_size = 1000M<br>       innodb_additional_mem_pool_size = 20M<br>       # Set .._log_file_size to 25 % of buffer pool size<br>       innodb_log_file_size = 500M<br>       innodb_log_buffer_size = 20M<br>       innodb_flush_log_at_trx_commit = 0<br>       innodb_lock_wait_timeout = 50<br>       设置完后一定记得把MySQL安装目录地址（我们目前是默认安装所以地址/var/lib/mysql/）下的ib_logfile0和ib_logfile1删除掉。否则重启MySQL起动失败。<br>   </p>

</blockquote>
<h2 id="MySQL缓存变量介绍及修改"><a href="#MySQL缓存变量介绍及修改" class="headerlink" title="MySQL缓存变量介绍及修改"></a>MySQL缓存变量介绍及修改</h2><blockquote>
   <p><br>       数据库属于IO密集型的应用程序，其主职责就是数据的管理及存储工作。而我们知道，从内存中读取一个数据库的时间是微秒级别，而从一块普通硬盘上读取一个 IO是在毫秒级别，二者相差3个数量级。所以，要优化数据库，首先第一步需要优化的就是IO，尽可能将磁盘IO转化为内存IO。本文先从MySQL数据库 IO相关参数(缓存参数)的角度来看看可以通过哪些参数进行IO优化<br>   </p> 

</blockquote>
<h3 id="全局缓存"><a href="#全局缓存" class="headerlink" title="全局缓存"></a>全局缓存</h3><blockquote>
   <p><br>       启动MySQL时就要分配并且总是存在的全局缓存。目前有：key_buffer_size(默认值：402653184,即384M)、innodb_buffer_pool_size(默认值：134217728即：128M)、innodb_additional_mem_pool_size（默认值：8388608即：8M）、innodb_log_buffer_size(默认值：8388608即：8M)、query_cache_size(默认值：33554432即：32M)等五个。总共：560M.<br>       这些变量值都可以通过命令如：show variables like ‘变量名’;查看到。<br>   </p> 

</blockquote>
<h4 id="key-buffer-size-本系统目前为384M-可修改为400M"><a href="#key-buffer-size-本系统目前为384M-可修改为400M" class="headerlink" title="key_buffer_size,本系统目前为384M,可修改为400M"></a>key_buffer_size,本系统目前为384M,可修改为400M</h4><blockquote>
   <p><br>       key_buffer_size=400M<br>       key_buffer_size是用于索引块的缓冲区大小，增加它可得到更好处理的索引(对所有读和多重写)，对MyISAM(MySQL表存储的一种类型，可以百度等查看详情)表性能影响最大的一个参数。如果你使它太大，系统将开始换页并且真的变慢了。严格说是它决定了数据库索引处理的速度，尤其是索引读的速度。对于内存在4GB左右的服务器该参数可设置为256M或384M.<br>        怎么才能知道key_buffer_size的设置是否合理呢，一般可以检查状态值Key_read_requests和Key_reads   ，比例key_reads / key_read_requests应该尽可能的低，比如1:100，1:1000 ，1:10000。其值可以用以下命令查得：show status like ‘key_read%’;<br>        比如查看系统当前key_read和key_read_request值为：<br>       +——————-+——-+<br>       | Variable_name     | Value |<br>       +——————-+——-+<br>       | Key_read_requests | 28535 |<br>       | Key_reads         | 269   |<br>       +——————-+——-+<br>       可知道有28535个请求，有269个请求在内存中没有找到直接从硬盘读取索引.<br>       未命中缓存的概率为：0.94%=269/28535*100%.  一般未命中概率在0.1之下比较好。目前已远远大于0.1，证明效果不好。若命中率在0.01以下，则建议适当的修改key_buffer_size值。<br>       <a href="http://dbahacker.com/mysql/innodb-myisam-compare(InnoDB与MyISAM的六大区别" target="_blank" rel="external">http://dbahacker.com/mysql/innodb-myisam-compare(InnoDB与MyISAM的六大区别</a>)<br>       <a href="http://kb.cnblogs.com/page/99810/（查看存储引擎介绍）" target="_blank" rel="external">http://kb.cnblogs.com/page/99810/（查看存储引擎介绍）</a><br>       MyISAM、InnoDB、MyISAM Merge引擎、InnoDB、memory(heap)、archive<br>   </p>

</blockquote>
<h4 id="innodb-buffer-pool-size-默认128M"><a href="#innodb-buffer-pool-size-默认128M" class="headerlink" title="innodb_buffer_pool_size(默认128M)"></a>innodb_buffer_pool_size(默认128M)</h4><blockquote>
   <p><br>       innodb_buffer_pool_size=1024M(1G)<br>       innodb_buffer_pool_size:主要针对InnoDB表性能影响最大的一个参数。功能与Key_buffer_size一样。InnoDB占用的内存，除innodb_buffer_pool_size用于存储页面缓存数据外，另外正常情况下还有大约8%的开销，主要用在每个缓存页帧的描述、adaptive hash等数据结构，如果不是安全关闭，启动时还要恢复的话，还要另开大约12%的内存用于恢复，两者相加就有差不多21%的开销。假设：12G的innodb_buffer_pool_size，最多的时候InnoDB就可能占用到14.5G的内存。若系统只有16G，而且只运行MySQL，且MySQL只用InnoDB，<br>       那么为MySQL开12G，是最大限度地利用内存了。<br>       另外InnoDB和 MyISAM 存储引擎不同， MyISAM 的 key_buffer_size 只能缓存索引键，而 innodb_buffer_pool_size 却可以缓存数据块和索引键。适当的增加这个参数的大小，可以有效的减少 InnoDB 类型的表的磁盘 I/O 。<br>       当我们操作一个 InnoDB 表的时候，返回的所有数据或者去数据过程中用到的任何一个索引块，都会在这个内存区域中走一遭。<br>       可以通过 (Innodb_buffer_pool_read_requests – Innodb_buffer_pool_reads) / Innodb_buffer_pool_read_requests <em> 100% 计算缓存命中率，并根据命中率来调整 innodb_buffer_pool_size 参数大小进行优化。值可以用以下命令查得：show status like ‘Innodb_buffer_pool_read%’;<br>       比如查看当前系统中系统中<br>        | Innodb_buffer_pool_read_requests      | 1283826 |<br>        | Innodb_buffer_pool_reads              | 519     |<br>        +—————————————+———+<br>        其命中率99.959%=（1283826-519）/1283826</em>100%  命中率越高越好。<br>   </p>

</blockquote>
<h4 id="innodb-additional-mem-pool-size-默认8M"><a href="#innodb-additional-mem-pool-size-默认8M" class="headerlink" title="innodb_additional_mem_pool_size(默认8M)"></a>innodb_additional_mem_pool_size(默认8M)</h4><blockquote>
   <p><br>       innodb_additional_mem_pool_size=20M<br>     innodb_additional_mem_pool_size 设置了InnoDB存储引擎用来存放数据字典信息以及一些内部数据结构的内存空间大小，所以当我们一个MySQL Instance中的数据库对象非常多的时候，是需要适当调整该参数的大小以确保所有数据都能存放在内存中提高访问效率的。<br>        这个参数大小是否足够还是比较容易知道的，因为当过小的时候，MySQL会记录Warning信息到数据库的error log中，这时候你就知道该调整这个参数大小了。<br>        查看当前系统mysql的error日志  cat  /var/lib/mysql/机器名.error 发现有很多waring警告。所以要调大为20M.<br>        根据MySQL手册，对于2G内存的机器，推荐值是20M。<br>            32G内存的 100M<br>   </p>

</blockquote>
<h4 id="innodb-log-buffer-size-默认8M"><a href="#innodb-log-buffer-size-默认8M" class="headerlink" title="innodb_log_buffer_size(默认8M)"></a>innodb_log_buffer_size(默认8M)</h4><blockquote>
   <p><br>        innodb_log_buffer_size=20M<br>            innodb_log_buffer_size  这是InnoDB存储引擎的事务日志所使用的缓冲区。类似于Binlog Buffer，InnoDB在写事务日志的时候，为了提高性能，也是先将信息写入Innofb Log Buffer中，当满足innodb_flush_log_trx_commit参数所设置的相应条件(或者日志缓冲区写满)之后，才会将日志写到文件 (或者同步到磁盘)中。可以通过innodb_log_buffer_size 参数设置其可以使用的最大内存空间。<br>       InnoDB 将日志写入日志磁盘文件前的缓冲大小。理想值为 1M 至 8M。大的日志缓冲允许事务运行时不需要将日志保存入磁盘而只到事务被提交(commit)。 因此，如果有大的事务处理，设置大的日志缓冲可以减少磁盘I/O。 在 my.cnf中以数字格式设置。<br>        默认是8MB，系的如频繁的系统可适当增大至4MB～8MB。当然如上面介绍所说，这个参数实际上还和另外的flush参数相关。一般来说不建议超过32MB<br>        注：innodb_flush_log_trx_commit参数对InnoDB Log的写入性能有非常关键的影响,默认值为1。该参数可以设置为0，1，2，解释如下：<br>        0：log buffer中的数据将以每秒一次的频率写入到log file中，且同时会进行文件系统到磁盘的同步操作，但是每个事务的commit并不会触发任何log buffer 到log file的刷新或者文件系统到磁盘的刷新操作;<br>        1：在每次事务提交的时候将log buffer 中的数据都会写入到log file，同时也会触发文件系统到磁盘的同步;<br>        2：事务提交会触发log buffer到log file的刷新，但并不会触发磁盘文件系统到磁盘的同步。此外，每秒会有一次文件系统到磁盘同步操作。<br>        实际测试发现，该值对插入数据的速度影响非常大，设置为2时插入10000条记录只需要2秒，设置为0时只需要1秒，而设置为1时则需要229秒。因此，MySQL手册也建议尽量将插入操作合并成一个事务，这样可以大幅提高速度。根据MySQL手册，在存在丢失最近部分事务的危险的前提下，可以把该值设为0。<br>   </p>

</blockquote>
<h4 id="query-cache-size-默认32M"><a href="#query-cache-size-默认32M" class="headerlink" title="query_cache_size(默认32M)"></a>query_cache_size(默认32M)</h4><blockquote>
   <p><br>        query_cache_size=40M<br>     query_cache_size: 主要用来缓存MySQL中的ResultSet，也就是一条SQL语句执行的结果集，所以仅仅只能针对select语句。当我们打开了 Query Cache功能，MySQL在接受到一条select语句的请求后，如果该语句满足Query Cache的要求(未显式说明不允许使用Query Cache，或者已经显式申明需要使用Query Cache)，MySQL会直接根据预先设定好的HASH算法将接受到的select语句以字符串方式进行hash，然后到Query Cache中直接查找是否已经缓存。也就是说，如果已经在缓存中，该select请求就会直接将数据返回，从而省略了后面所有的步骤(如SQL语句的解析，优化器优化以及向存储引擎请求数据等)，极大的提高性能。根据MySQL用户手册，使用查询缓冲最多可以达到238%的效率。<br>        当然，Query Cache也有一个致命的缺陷，那就是当某个表的数据有任何任何变化，都会导致所有引用了该表的select语句在Query Cache中的缓存数据失效。所以，当我们的数据变化非常频繁的情况下，使用Query Cache可能会得不偿失<br>       Query Cache的使用需要多个参数配合，其中最为关键的是query_cache_size和query_cache_type，前者设置用于缓存 ResultSet的内存大小，后者设置在何场景下使用Query Cache。在以往的经验来看，如果不是用来缓存基本不变的数据的MySQL数据库，query_cache_size一般256MB是一个比较合适的大小。当然，这可以通过计算Query Cache的命中率(Qcache_hits/(Qcache_hits+Qcache_inserts)*100))来进行调整。 query_cache_type可以设置为0(OFF)，1(ON)或者2(DEMOND)，分别表示完全不使用query cache，除显式要求不使用query cache(使用sql_no_cache)之外的所有的select都使用query cache，只有显示要求才使用query cache(使用sql_cache)。如果Qcache_lowmem_prunes的值非常大，则表明经常出现缓冲. 如果Qcache_hits的值也非常大，则表明查询缓冲使用非常频繁，此时需要增加缓冲大小；<br>        根据命中率(Qcache_hits/(Qcache_hits+Qcache<em>inserts)*100))进行调整，一般不建议太大，256MB可能已经差不多了，大型的配置型静态数据可适当调大.<br>        可以通过命令：show status like ‘Qcache</em>%’;查看目前系统Query catch使用大小<br>        | Qcache_hits             | 1892463  |<br>        | Qcache_inserts          | 35627<br>        命中率98.17%=1892463/(1892463 +35627 )*100<br>   </p>

</blockquote>
<h3 id="局部缓存"><a href="#局部缓存" class="headerlink" title="局部缓存"></a>局部缓存</h3><blockquote>
   <p><br>        除了全局缓冲，MySql还会为每个连接发放连接缓冲。个连接到MySQL服务器的线程都需要有自己的缓冲。大概需要立刻分配256K，甚至在线程空闲时，它们使用默认的线程堆栈，网络缓存等。事务开始之后，则需要增加更多的空间。运行较小的查询可能仅给指定的线程增加少量的内存消耗，然而如果对数据表做复杂的操作例如扫描、排序或者需要临时表，则需分配大约read_buffer_size，<br>        sort_buffer_size，read_rnd_buffer_size，tmp_table_size 大小的内存空间. 不过它们只是在需要的时候才分配，并且在那些操作做完之后就释放了。有的是立刻分配成单独的组块。tmp_table_size 可能高达MySQL所能分配给这个操作的最大内存空间了<br>        。注意，这里需要考虑的不只有一点——可能会分配多个同一种类型的缓存，例如用来处理子查询。一些特殊的查询的内存使用量可能更大——如果在MyISAM表上做成批的插入<br>        时需要分配 bulk_insert_buffer_size 大小的内存；执行 ALTER TABLE， OPTIMIZE TABLE， REPAIR TABLE 命令时需要分配 myisam_sort_buffer_size 大小的内存。<br>   </p>

</blockquote>
<h4 id="read-buffer-size（默认值：2097144即2M）"><a href="#read-buffer-size（默认值：2097144即2M）" class="headerlink" title="read_buffer_size（默认值：2097144即2M）"></a>read_buffer_size（默认值：2097144即2M）</h4><blockquote>
   <p><br>        read_buffer_size=4M<br>       read_buffer_size 是MySql读入缓冲区大小。对表进行顺序扫描的请求将分配一个读入缓冲区，MySql会为它分配一段内存缓冲区。read_buffer_size变量控制这一<br>        缓冲区的大小。如果对表的顺序扫描请求非常频繁，并且你认为频繁扫描进行得太慢，可以通过增加该变量值以及内存缓冲区大小提高其性能.<br>   </p> 

</blockquote>
<h4 id="sort-buffer-size（默认值：2097144即2M）"><a href="#sort-buffer-size（默认值：2097144即2M）" class="headerlink" title="sort_buffer_size（默认值：2097144即2M）"></a>sort_buffer_size（默认值：2097144即2M）</h4><blockquote>
   <p><br>        sort_buffer_size=4M<br>    sort_buffer_size是MySql执行排序使用的缓冲大小。如果想要增加ORDER BY的速度，首先看是否可以让MySQL使用索引而不是额外的排序阶段。如果不能，可以尝试增加sort_buffer_size变量的大小<br>   </p>

</blockquote>
<h4 id="read-rnd-buffer-size-默认值：8388608即8M"><a href="#read-rnd-buffer-size-默认值：8388608即8M" class="headerlink" title="read_rnd_buffer_size(默认值：8388608即8M)"></a>read_rnd_buffer_size(默认值：8388608即8M)</h4><blockquote>
   <p><br>        read_rnd_buffer_size=8M<br>        read_rnd_buffer_size 是MySql的随机读缓冲区大小。当按任意顺序读取行时(例如，按照排序顺序)，将分配一个随机读缓存区。进行排序查询时，MySql会首先扫描一遍该缓冲，以避免磁盘搜索，提高查询速度，如果需要排序大量数据，可适当调高该值。但MySql会为每个客户连接发放该缓冲空间，所以应尽量适当设置该值，以避免内存开销过大。<br>   </p>

</blockquote>
<h4 id="tmp-table-size-默认值：8388608-即：16M"><a href="#tmp-table-size-默认值：8388608-即：16M" class="headerlink" title="tmp_table_size(默认值：8388608 即：16M)"></a>tmp_table_size(默认值：8388608 即：16M)</h4><blockquote>
   <p><br>        tmp_table_size=16M<br>       tmp_table_size是MySql的heap （堆积）表缓冲大小。所有联合在一个DML指令内完成，并且大多数联合甚至可以不用临时表即可以完成。大多数临时表是基于内<br>        存的(HEAP)表。具有大的记录长度的临时表 (所有列的长度的和)或包含BLOB列的表存储在硬盘上。如果某个内部heap（堆积）表大小超过tmp_table_size，MySQL可以根据需要自<br>        动将内存中的heap表改为基于硬盘的MyISAM表。还可以通过设置tmp_table_size选项来增加临时表的大小。也就是说，如果调高该值，MySql同时将增加heap表的大小，可达到提高联接查询速度的效果。<br>   </p>

</blockquote>
<h4 id="record-buffer-（默认值：）"><a href="#record-buffer-（默认值：）" class="headerlink" title="record_buffer:（默认值：）"></a>record_buffer:（默认值：）</h4><blockquote>
   <p><br>        record_buffer每个进行一个顺序扫描的线程为其扫描的每张表分配这个大小的一个缓冲区。如果你做很多顺序扫描，你可能想要增加该值。默认数值是131072(128K)<br>   </p>

</blockquote>
<h3 id="其它缓存："><a href="#其它缓存：" class="headerlink" title="其它缓存："></a>其它缓存：</h3><h4 id="table-cache-默认值：512"><a href="#table-cache-默认值：512" class="headerlink" title="table_cache(默认值：512)"></a>table_cache(默认值：512)</h4><blockquote>
   <p><br>        TABLE_CACHE(5.1.3及以后版本又名TABLE_OPEN_CACHE)<br>        table_cache指定表高速缓存的大小。每当MySQL访问一个表时，如果在表缓冲区中还有空间，该表就被打开并放入其中，这样可以更快地访问表内容。通过检查峰值时间的状态值Open_tables和Opened_tables，可以决定是否需要增加table_cache的值。如果你发现open_tables等于table_cache，并且opened_tables在不断增长，那么你就需要增加table_cache的值了（上述状态值可以使用SHOW STATUS LIKE ‘Open%tables’获得）。注意，不能盲目地把table_cache设置成很大的值。如果设置得太高，可能会造成文件描述符不足，从而造成性能不稳定或者连接失败。<br>        SHOW STATUS LIKE ‘Open%tables’;<br>        +—————+——-+<br>        | Variable_name | Value |<br>        +—————+——-+<br>        | Open_tables   | 356   |<br>        | Opened_tables | 0     |<br>        +—————+——-+<br>        2 rows in set (0.00 sec)<br>        open_tables表示当前打开的表缓存数，如果执行flush tables操作，则此系统会关闭一些当前没有使用的表缓存而使得此状态值减小；<br>        opend_tables表示曾经打开的表缓存数，会一直进行累加，如果执行flush tables操作，值不会减小。<br>        在mysql默认安装情况下，table_cache的值在2G内存以下的机器中的值默认时256到512，如果机器有4G内存,则默认这个值 是2048，但这决意味着机器内存越大，这个值应该越大，因为table_cache加大后，使得mysql对SQL响应的速度更快了，不可避免的会产生 更多的死锁（dead lock），这样反而使得数据库整个一套操作慢了下来，严重影响性能。所以平时维护中还是要根据库的实际情况去作出判断，找到最适合你维护的库的 table_cache值。<br>        由于MySQL是多线程的机制,为了提高性能,每个线程都是独自打开自己需要的表的文件描 述符,而不是通过共享已经打开的.针对不同存储引擎处理的方法当然也不一样<br>        在myisam表引擎中,数据文件的描述符 (descriptor)是不共享的,但是索引文件的描述符却是所有线程共享的.Innodb中和使用表空间类型有关,假如是共享表空间那么实际就一个数 据文件,当然占用的数据文件描述符就会比独立表空间少.<br>       mysql手册上给的建议大小 是:table_cache=max_connections*n<br>       n表示查询语句中最大表数, 还需要为临时表和文件保留一些额外的文件描述符。<br>       这个数据遭到很多质疑,table_cache够用就好,检查 Opened_tables值,如果这个值很大,或增长很快那么你就得考虑加大table_cache了.<br>       table_cache：所有线程打开的表的数目。增大该值可以增加mysqld需要的文件描述符的数量。默认值是64.<br>   </p>


</blockquote>
<h4 id="thread-cache-size-服务器线程缓存"><a href="#thread-cache-size-服务器线程缓存" class="headerlink" title="thread_cache_size (服务器线程缓存)"></a>thread_cache_size (服务器线程缓存)</h4><blockquote>
   <p><br>       thread_cache_size=64<br>       默认的thread_cache_size=8，但是看到好多配置的样例里的值一般是32，64，甚至是128，感觉这个参数对优化应该有帮助，于是查了下：<br>       根据调查发现以上服务器线程缓存thread_cache_size没有进行设置，或者设置过小,这个值表示可以重新利用保存在缓存中线程的数量,当断开连接时如果缓存中还有空间,那么客户端的线程将被放到缓存中,如果线程重新被请求，那么请求将从缓存中读取,如果缓存中是空的或者是新的请求，那么这个线程将被重新创建,如果有很多新的线程，增加这个值可以改善系统性能.通过比较 Connections 和 Threads_created 状态的变量，可以看到这个变量的作用。(–&gt;表示要调整的值)   根据物理内存设置规则如下：<br>       1G —&gt; 8<br>       2G —&gt; 16<br>       3G —&gt; 32     &gt;3G —&gt; 64<br>         mysql&gt; show status like ‘thread%’;<br>       +——————-+——-+<br>       | Variable_name     | Value |<br>       +——————-+——-+<br>       | Threads_cached    | 0     |  &lt;—当前被缓存的空闲线程的数量<br>       | Threads_connected | 1     |  &lt;—正在使用（处于连接状态）的线程<br>       | Threads_created   | 1498  |  &lt;—服务启动以来，创建了多少个线程<br>       | Threads_running   | 1     |  &lt;—正在忙的线程（正在查询数据，传输数据等等操作）<br>       +——————-+——-+<br>       查看开机起来数据库被连接了多少次？<br>       mysql&gt; show status like ‘%connection%’;<br>       +———————-+——-+<br>       | Variable_name        | Value |<br>       +———————-+——-+<br>       | Connections          | 1504  |          –&gt;服务启动以来，历史连接数<br>       | Max_used_connections | 2     |<br>       +———————-+——-+<br>       通过连接线程池的命中率来判断设置值是否合适？命中率超过90%以上,设定合理。<br>       (Connections -  Threads_created) / Connections * 100 %<br>   </p>
</blockquote>

      
    </div>

    <div>
      
        
      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/cobar/" rel="tag">#cobar</a>
          
            <a href="/tags/MySQL/" rel="tag">#MySQL</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/05/12/hexo-deploy-时-github-pulickey-denied的问题/" rel="next" title="hexo deploy 时 github pulickey denied的问题">
                <i class="fa fa-chevron-left"></i> hexo deploy 时 github pulickey denied的问题
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/05/25/关闭MySQL的QueryCache/" rel="prev" title="慎用MySQL的QueryCache!">
                慎用MySQL的QueryCache! <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
  <a class="jiathis_button_tsina"></a>
  <a class="jiathis_button_tqq"></a>
  <a class="jiathis_button_weixin"></a>
  <a class="jiathis_button_cqq"></a>
  <a class="jiathis_button_douban"></a>
  <a class="jiathis_button_renren"></a>
  <a class="jiathis_button_qzone"></a>
  <a class="jiathis_button_kaixin001"></a>
  <a class="jiathis_button_copy"></a>
  <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank"></a>
  <a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" >
  var jiathis_config={
    hideMore:false
  }
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js" charset="utf-8"></script>
<!-- JiaThis Button END -->

      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2016/05/16/cobar集群单点积压/"
           data-title="cobar集群单点积压" data-url="http://yoursite.com/2016/05/16/cobar集群单点积压/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar.png"
               alt="Jerry Hong" />
          <p class="site-author-name" itemprop="name">Jerry Hong</p>
          <p class="site-description motion-element" itemprop="description">记录点滴</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">9</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Cobar集群积压问题"><span class="nav-number">1.</span> <span class="nav-text">Cobar集群积压问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#一直困扰的集群单点积压"><span class="nav-number">1.1.</span> <span class="nav-text">一直困扰的集群单点积压</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#问题分析"><span class="nav-number">1.2.</span> <span class="nav-text">问题分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#尝试解决"><span class="nav-number">1.3.</span> <span class="nav-text">尝试解决</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#问题再现"><span class="nav-number">1.4.</span> <span class="nav-text">问题再现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fix"><span class="nav-number">1.5.</span> <span class="nav-text">fix!</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL非缓存参数变量介绍及修改"><span class="nav-number">1.6.</span> <span class="nav-text">MySQL非缓存参数变量介绍及修改</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#back-log"><span class="nav-number">1.6.1.</span> <span class="nav-text">back_log</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#wait-timeout"><span class="nav-number">1.6.2.</span> <span class="nav-text">wait_timeout</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#max-connections"><span class="nav-number">1.6.3.</span> <span class="nav-text">max_connections</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#max-user-connections"><span class="nav-number">1.6.4.</span> <span class="nav-text">max_user_connections</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#thread-concurrency"><span class="nav-number">1.6.5.</span> <span class="nav-text">thread_concurrency</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#skip-name-resolve"><span class="nav-number">1.6.6.</span> <span class="nav-text">skip-name-resolve</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#skip-networking"><span class="nav-number">1.6.7.</span> <span class="nav-text">skip-networking</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#default-storage-engine"><span class="nav-number">1.6.8.</span> <span class="nav-text">default-storage-engine</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL缓存变量介绍及修改"><span class="nav-number">1.7.</span> <span class="nav-text">MySQL缓存变量介绍及修改</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#全局缓存"><span class="nav-number">1.7.1.</span> <span class="nav-text">全局缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#key-buffer-size-本系统目前为384M-可修改为400M"><span class="nav-number">1.7.1.1.</span> <span class="nav-text">key_buffer_size,本系统目前为384M,可修改为400M</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#innodb-buffer-pool-size-默认128M"><span class="nav-number">1.7.1.2.</span> <span class="nav-text">innodb_buffer_pool_size(默认128M)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#innodb-additional-mem-pool-size-默认8M"><span class="nav-number">1.7.1.3.</span> <span class="nav-text">innodb_additional_mem_pool_size(默认8M)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#innodb-log-buffer-size-默认8M"><span class="nav-number">1.7.1.4.</span> <span class="nav-text">innodb_log_buffer_size(默认8M)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#query-cache-size-默认32M"><span class="nav-number">1.7.1.5.</span> <span class="nav-text">query_cache_size(默认32M)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#局部缓存"><span class="nav-number">1.7.2.</span> <span class="nav-text">局部缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#read-buffer-size（默认值：2097144即2M）"><span class="nav-number">1.7.2.1.</span> <span class="nav-text">read_buffer_size（默认值：2097144即2M）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sort-buffer-size（默认值：2097144即2M）"><span class="nav-number">1.7.2.2.</span> <span class="nav-text">sort_buffer_size（默认值：2097144即2M）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#read-rnd-buffer-size-默认值：8388608即8M"><span class="nav-number">1.7.2.3.</span> <span class="nav-text">read_rnd_buffer_size(默认值：8388608即8M)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#tmp-table-size-默认值：8388608-即：16M"><span class="nav-number">1.7.2.4.</span> <span class="nav-text">tmp_table_size(默认值：8388608 即：16M)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#record-buffer-（默认值：）"><span class="nav-number">1.7.2.5.</span> <span class="nav-text">record_buffer:（默认值：）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其它缓存："><span class="nav-number">1.7.3.</span> <span class="nav-text">其它缓存：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#table-cache-默认值：512"><span class="nav-number">1.7.3.1.</span> <span class="nav-text">table_cache(默认值：512)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#thread-cache-size-服务器线程缓存"><span class="nav-number">1.7.3.2.</span> <span class="nav-text">thread_cache_size (服务器线程缓存)</span></a></li></ol></li></ol></li></ol></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jerry Hong</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"hongjinwei"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
  





  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
       search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').toggle();

    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
    'use strict';
    $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
            // get the contents from search data
            isfetched = true;
            $('.popup').detach().appendTo('.header-inner');
            var datas = $( "entry", xmlResponse ).map(function() {
                return {
                    title: $( "title", this ).text(),
                    content: $("content",this).text(),
                    url: $( "url" , this).text()
                };
            }).get();
            var $input = document.getElementById(search_id);
            var $resultContent = document.getElementById(content_id);
            $input.addEventListener('input', function(){
                var matchcounts = 0;
                var str='<ul class=\"search-result-list\">';                
                var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                $resultContent.innerHTML = "";
                if (this.value.trim().length > 1) {
                // perform local searching
                datas.forEach(function(data) {
                    var isMatch = true;
                    var content_index = [];
                    var data_title = data.title.trim().toLowerCase();
                    var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                    var data_url = data.url;
                    var index_title = -1;
                    var index_content = -1;
                    var first_occur = -1;
                    // only match artiles with not empty titles and contents
                    if(data_title != '' && data_content != '') {
                        keywords.forEach(function(keyword, i) {
                            index_title = data_title.indexOf(keyword);
                            index_content = data_content.indexOf(keyword);
                            if( index_title < 0 && index_content < 0 ){
                                isMatch = false;
                            } else {
                                if (index_content < 0) {
                                    index_content = 0;
                                }
                                if (i == 0) {
                                    first_occur = index_content;
                                }
                            }
                        });
                    }
                    // show search results
                    if (isMatch) {
                        matchcounts += 1;
                        str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                        var content = data.content.trim().replace(/<[^>]+>/g,"");
                        if (first_occur >= 0) {
                            // cut out 100 characters
                            var start = first_occur - 20;
                            var end = first_occur + 80;
                            if(start < 0){
                                start = 0;
                            }
                            if(start == 0){
                                end = 50;
                            }
                            if(end > content.length){
                                end = content.length;
                            }
                            var match_content = content.substring(start, end);
                            // highlight all keywords
                            keywords.forEach(function(keyword){
                                var regS = new RegExp(keyword, "gi");
                                match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                            });
                            
                            str += "<p class=\"search-result\">" + match_content +"...</p>"
                        }
                        str += "</li>";
                    }
                })};
                str += "</ul>";
                if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
                if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
                $resultContent.innerHTML = str;
            });
            proceedsearch();
        }
    });}

    // handle and trigger popup window;
    $('.popup-trigger').mousedown(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };

    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".popoverlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>

  
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
  </script>

  <script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for (i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  </script>
  <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


  

  

</body>
</html>
